#!/usr/local/bin/python# coding: utf-8"""leetcode 295 数据流的中位数设计一种数据结构，支持两种操作，包括从数据流中加入一个元素，和获取数据结构中元素的中位数。若元素个数为偶数，中位数定义为有序列表中间两个元素的均值；若元素个数为奇数，中位数为中间一个元素。思路：此题为求动态数据结构的中位数，维护一个大顶堆，一个小顶堆，其中大顶堆的元素都小于小顶堆的元素。有新的元素时，若比大顶堆堆顶元素小，入大顶堆，调整大顶堆；否则入小顶堆，调整小顶堆。每次有元素入堆后，需要比较两个堆的元素数量，若总元素个数为偶数，则两个堆元素个数相等，返回堆顶元素的均值；若元素总数为奇数，则大顶堆元素比小顶堆元素多一，返回大顶堆堆顶元素。注意；由于Python中的heapq是小顶堆优先级队列，在对大顶堆操作的时候传入元素的相反数。"""from heapq import heappush, heappopclass MedianFinder:    def __init__(self):        """        initialize your data structure here.        """        self.maxheap = []        self.minheap = []    def addNum(self, num: int) -> None:        # 元素入堆        if not self.maxheap or num < -self.maxheap[0]:            heappush(self.maxheap, -num)        else:            heappush(self.minheap, num)        # 调整两个堆的数目（minheap的数目永远是(n1+n2)//2）        n1, n2 = len(self.maxheap), len(self.minheap)        if n2 < (n1+n2)//2:  # minheap数量太少了            for i in range((n1+n2)//2-n2):                x = heappop(self.maxheap)                heappush(self.minheap, -x)        elif n2 > (n1+n2)//2:  # minheap数量太多了            for i in range(n2-(n1+n2)//2):                x = heappop(self.minheap)                heappush(self.maxheap, -x)    def findMedian(self) -> float:        if (len(self.maxheap) + len(self.minheap)) % 2 == 0:            return (self.minheap[0] - self.maxheap[0])/2        else:            return -self.maxheap[0]# Your MedianFinder object will be instantiated and called as such:obj = MedianFinder()obj.addNum(1)obj.addNum(2)print(obj.findMedian())obj.addNum(3)print(obj.findMedian())